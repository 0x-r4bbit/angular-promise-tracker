angular.module("promiseTracker",[]).provider("promiseTracker",function(){var trackers={};this.$get=["$q","$timeout",function($q,$timeout){var self=this;function Tracker(options){options=options||{};var self=this,callbacks={start:[],done:[],error:[],success:[]},trackedPromises=[];self.setMinDuration=function(minimum){self._minDuration=minimum};self.setMinDuration(options.minDuration);self.setMaxDuration=function(maximum){self._maxDuration=maximum};self.setMaxDuration(options.maxDuration);self.active=function(){return trackedPromises.length>0};self.cancel=function(){angular.forEach(trackedPromises,function(deferred){deferred.resolve()})};function fireEvent(event,params){angular.forEach(callbacks[event],function(cb){cb.apply(self,params||[])})}function createPromise(startArg){var deferred=$q.defer();trackedPromises.push(deferred);fireEvent("start",[startArg]);if(trackedPromises.length==1){if(self._minDuration){self.minPromise=$timeout(angular.noop,self._minDuration)}else{self.minPromise=$q.when(true)}if(self._maxDuration){self.maxPromise=$timeout(deferred.resolve,self._maxDuration)}}function onDone(isError){return function(value){self.minPromise.then(function(){fireEvent("done",[value,isError]);fireEvent(isError?"error":"success",[value]);var index=trackedPromises.indexOf(deferred);trackedPromises.splice(index,1);if(trackedPromises.length===0&&self.maxPromise){$timeout.cancel(self.maxPromise)}})}}deferred.promise.then(onDone(false),onDone(true));return deferred}self.addPromise=function(promise,startArg){var deferred=createPromise(startArg);promise.then(function success(value){deferred.resolve(value);return value},function error(value){deferred.reject(value);return $q.reject(value)});return deferred};self.createPromise=function(startArg){return createPromise(startArg)};self.on=self.bind=function(event,cb){if(!callbacks[event]){throw"Cannot create callback for event '"+event+"'. Allowed types: 'start', 'done', 'error', 'success'"}callbacks[event].push(cb);return self};self.off=self.unbind=function(event,cb){if(!callbacks[event]){throw"Cannot create callback for event '"+event+"'. Allowed types: 'start', 'done', 'error', 'success'"}if(cb){var index=callbacks[event].indexOf(cb);callbacks[event].splice(index,1)}else{callbacks[event].length=0}return self}}return function promiseTracker(trackerName,options){if(!trackers[trackerName]){trackers[trackerName]=new Tracker(options)}return trackers[trackerName]}}]}).config(["$httpProvider",function($http){if($http.interceptors){$http.interceptors.push("trackerHttpInterceptor")}else{$http.responseInterceptors.push("trackerResponseInterceptor")}}]).factory("trackerResponseInterceptor",["$q","promiseTracker","$injector",function($q,promiseTracker,$injector){var $http;return function spinnerResponseInterceptor(promise){if(!$http)$http=$injector.get("$http");var config=$http.pendingRequests[$http.pendingRequests.length-1];if(config.tracker){promiseTracker(config.tracker).addPromise(promise,config)}return promise}}]).factory("trackerHttpInterceptor",["$q","promiseTracker","$injector",function($q,promiseTracker,$injector){return{request:function(config){if(config.tracker){var deferred=promiseTracker(config.tracker).createPromise(config);config.$promiseTrackerDeferred=deferred}return $q.when(config)},response:function(response){if(response.config.$promiseTrackerDeferred){response.config.$promiseTrackerDeferred.resolve(response)}return $q.when(response)},responseError:function(response){if(response.config.$promiseTrackerDeferred){response.config.$promiseTrackerDeferred.reject(response)}return $q.reject(response)}}}]);
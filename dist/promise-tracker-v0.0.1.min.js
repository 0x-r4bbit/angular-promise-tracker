/*
 * angular-promise-tracker, version 0.1.0
 * http://github.com/ajoslin/angular-promise-tracker
 * Licensed with MIT License
 */angular.module("promiseTracker",[]).factory("promiseTracker",function(e){function r(t){function s(e,t){o("done",[e,t]),t?o("error",[e]):o("success",[e]),r--}function o(e,t){angular.forEach(i[e],function(e){e.apply(n,t||[])})}var n=this,r=0,i={start:[],done:[],error:[],success:[]};n.active=function(){return r>0},n.on=n.bind=function(e,t){if(!i[e])throw"Cannot create callback for event '"+e+"'. Allowed types: 'start', 'done', 'error', 'success'";return i[e].push(t),n},n.off=n.unbind=function(e,t){if(!i[e])throw"Cannot create callback for event '"+e+"'. Allowed types: 'start', 'done', 'error', 'success'";if(t){var n=i[e].indexOf(t);i[e].splice(t,1)}else i[e].length=0},n.addPromise=function(t,n){return r++,o("start",[n]),t.then(function(t){return s(t),t},function(n){return s(n,!0),e.reject(n)})}}var t=this,n={};return function(e){return n[e]||(n[e]=new r(e)),n[e]}}).config(function(e){e.responseInterceptors.push("trackerResponseInterceptor")}).factory("trackerResponseInterceptor",function(e,t,n){var r;return function(i){r||(r=n.get("$http"));var s=r.pendingRequests[r.pendingRequests.length-1],o;if(o=s.tracker)angular.isArray(o)||(o=[o]),angular.forEach(o,function(e){t(e).addPromise(i,s)});return i}});